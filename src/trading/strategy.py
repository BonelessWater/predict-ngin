"""
Strategy framework.

Base classes and interfaces for trading strategies.
Strategies generate signals that are processed by the trading engine.
"""

from __future__ import annotations

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from typing import Dict, List, Optional, Any, Set, Iterable, Union, Type
from enum import Enum

from .risk import RiskManager, RiskLimits, RiskModule, load_risk_modules
from .risk_profiles import get_risk_profile


class SignalType(Enum):
    """Type of trading signal."""

    BUY = "BUY"
    SELL = "SELL"
    CLOSE = "CLOSE"
    HOLD = "HOLD"


@dataclass
class Signal:
    """
    Trading signal generated by a strategy.

    Contains all information needed to execute a trade.
    """

    # Required
    strategy_name: str
    market_id: str
    signal_type: SignalType
    timestamp: datetime

    # Position details
    outcome: str = "YES"  # YES or NO
    size: float = 100.0
    price: Optional[float] = None  # Target price, if applicable

    # Market context
    category: str = "unknown"
    liquidity: float = 0.0
    volume_24h: float = 0.0
    spread: float = 0.0
    volatility: float = 0.20

    # Signal metadata
    confidence: float = 1.0  # 0-1 confidence score
    reason: str = ""
    features: Dict[str, Any] = field(default_factory=dict)

    # Risk-adjusted fields (set by risk manager)
    risk_adjusted_size: Optional[float] = None
    risk_check_passed: bool = True
    risk_rejection_reason: str = ""

    @property
    def side(self) -> str:
        """Convert signal type to side string."""
        if self.signal_type == SignalType.BUY:
            return "BUY"
        if self.signal_type == SignalType.SELL:
            return "SELL"
        return "HOLD"

    @property
    def effective_size(self) -> float:
        """Get risk-adjusted size if available."""
        return self.risk_adjusted_size if self.risk_adjusted_size else self.size

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for risk checks."""
        return {
            "strategy_name": self.strategy_name,
            "market_id": self.market_id,
            "signal_type": self.signal_type.value,
            "timestamp": self.timestamp,
            "outcome": self.outcome,
            "size": self.size,
            "price": self.price,
            "category": self.category,
            "liquidity": self.liquidity,
            "volume_24h": self.volume_24h,
            "spread": self.spread,
            "volatility": self.volatility,
            "confidence": self.confidence,
            "features": self.features,
        }


@dataclass
class StrategyConfig:
    """Configuration for a strategy."""

    name: str
    enabled: bool = True
    position_size: float = 100.0
    max_positions: int = 50
    confidence_threshold: float = 0.5
    parameters: Dict[str, Any] = field(default_factory=dict)


class Strategy(ABC):
    """
    Abstract base class for trading strategies.

    Subclass this to implement custom strategies.
    """

    def __init__(self, config: Optional[StrategyConfig] = None):
        self.config = config or StrategyConfig(name=self.__class__.__name__)
        self._positions: Set[str] = set()  # Track open positions

    @property
    def name(self) -> str:
        return self.config.name

    @abstractmethod
    def generate_signals(
        self,
        market_data: Dict[str, Any],
        timestamp: datetime,
    ) -> List[Signal]:
        """
        Generate trading signals from market data.

        Args:
            market_data: Current market state (prices, volumes, etc.)
            timestamp: Current time

        Returns:
            List of signals (can be empty)
        """

    def on_position_opened(self, market_id: str, signal: Signal):
        """Called when a position is opened."""
        self._positions.add(market_id)

    def on_position_closed(self, market_id: str, pnl: float):
        """Called when a position is closed."""
        self._positions.discard(market_id)

    def has_position(self, market_id: str) -> bool:
        """Check if we have an open position in a market."""
        return market_id in self._positions

    def reset(self):
        """Reset strategy state."""
        self._positions.clear()


class StrategyManager:
    """
    Manages multiple strategies and applies risk management.

    Usage:
        manager = StrategyManager(capital=10000)
        manager.add_strategy(MyStrategy())

        signals = manager.generate_signals(market_data, timestamp)
        for signal in signals:
            if signal.risk_check_passed:
                execute_trade(signal)
    """

    def __init__(
        self,
        capital: float = 10000.0,
        risk_limits: Optional[RiskLimits] = None,
        risk_modules: Optional[Iterable[Union[RiskModule, str, Type[RiskModule]]]] = None,
        risk_profile: Optional[str] = None,
    ):
        self.strategies: List[Strategy] = []
        if risk_profile:
            profile = get_risk_profile(risk_profile)
            if risk_limits is None:
                risk_limits = profile.limits
            if risk_modules is None:
                risk_modules = profile.modules

        modules = None if risk_modules is None else load_risk_modules(risk_modules)
        self.risk_manager = RiskManager(limits=risk_limits, modules=modules)
        self.risk_manager.initialize(capital)

    def add_strategy(self, strategy: Strategy):
        """Add a strategy to the manager."""
        self.strategies.append(strategy)

    def remove_strategy(self, name: str):
        """Remove a strategy by name."""
        self.strategies = [s for s in self.strategies if s.name != name]

    def enable_strategy(self, name: str, enabled: bool = True):
        """Enable or disable a strategy."""
        for strategy in self.strategies:
            if strategy.name == name:
                strategy.config.enabled = enabled

    def generate_signals(
        self,
        market_data: Dict[str, Any],
        timestamp: datetime,
    ) -> List[Signal]:
        """
        Generate signals from all strategies and apply risk checks.

        Returns signals with risk_check_passed set appropriately.
        """
        all_signals: List[Signal] = []

        # Generate signals from all strategies
        for strategy in self.strategies:
            if not strategy.config.enabled:
                continue

            try:
                signals = strategy.generate_signals(market_data, timestamp)
                all_signals.extend(signals)
            except Exception as exc:
                print(f"Error in strategy {strategy.name}: {exc}")

        # Apply risk checks
        approved_signals: List[Signal] = []
        for signal in all_signals:
            result = self.risk_manager.check_signal(signal.to_dict())

            signal.risk_check_passed = result.allowed

            if result.action.value == "reduce_size" and result.adjusted_size:
                signal.risk_adjusted_size = result.adjusted_size
            elif not result.allowed:
                signal.risk_rejection_reason = result.reason

            approved_signals.append(signal)

        # Sort by confidence
        approved_signals.sort(key=lambda s: s.confidence, reverse=True)

        return approved_signals

    def record_trade(self, signal: Signal, price: float):
        """Record a trade execution."""
        self.risk_manager.record_trade(
            market_id=signal.market_id,
            category=signal.category,
            outcome=signal.outcome,
            side=signal.side,
            size=signal.effective_size,
            price=price,
            timestamp=signal.timestamp,
        )

        # Notify strategy
        for strategy in self.strategies:
            if strategy.name == signal.strategy_name:
                strategy.on_position_opened(signal.market_id, signal)

    def close_position(self, position_id: str, exit_price: float, timestamp: datetime) -> float:
        """Close a position and return P&L."""
        pnl = self.risk_manager.close_position(position_id, exit_price, timestamp)
        return pnl

    def update_prices(self, prices: Dict[str, float]):
        """Update position prices."""
        self.risk_manager.update_prices(prices)

    def get_risk_report(self) -> Dict[str, Any]:
        """Get current risk state."""
        return self.risk_manager.get_risk_report()

    def reset(self):
        """Reset all strategies and risk state."""
        for strategy in self.strategies:
            strategy.reset()


def generate_signals(
    strategies: Iterable[Strategy],
    market_data: Dict[str, Any],
    timestamp: datetime,
    *,
    capital: float = 10000.0,
    risk_limits: Optional[RiskLimits] = None,
    risk_modules: Optional[Iterable[Union[RiskModule, str, Type[RiskModule]]]] = None,
    risk_profile: Optional[str] = None,
) -> List[Signal]:
    """
    Convenience helper to generate signals with risk checks.

    This loads risk modules, creates a manager, and returns the signals.
    """
    manager = StrategyManager(
        capital=capital,
        risk_limits=risk_limits,
        risk_modules=risk_modules,
        risk_profile=risk_profile,
    )
    for strategy in strategies:
        manager.add_strategy(strategy)
    return manager.generate_signals(market_data, timestamp)
