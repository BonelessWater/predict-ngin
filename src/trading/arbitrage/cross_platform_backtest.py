"""
Cross-platform arbitrage backtest engine.

Simulates arbitrage trades across Polymarket and Kalshi using signals
generated by ArbitrageStrategy. Tracks positions, P&L, fees, and
portfolio state on both platforms independently.

Usage:
    from trading.arbitrage import (
        run_arbitrage_backtest, ArbitrageBacktestConfig,
    )

    result = run_arbitrage_backtest(
        signals=signals_list,
        price_store=cross_platform_store,
        config=ArbitrageBacktestConfig(position_size=100),
    )
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional

import numpy as np
import pandas as pd

from .arbitrage_strategy import (
    ArbitrageSignal,
    PlatformFees,
    POLYMARKET_FEES,
    KALSHI_FEES,
)
from .cross_platform_price_store import CrossPlatformPriceStore
from ..reporting import (
    RunMetrics,
    RunMetadata,
    RunDiagnostics,
    RunSummary,
    compute_daily_returns,
)


# ---------------------------------------------------------------------------
# Config and result dataclasses
# ---------------------------------------------------------------------------

@dataclass
class ArbitrageBacktestConfig:
    """Configuration for cross-platform arbitrage backtests."""

    strategy_name: str = "Cross-Platform Arbitrage"
    position_size: float = 100.0  # USD per side (total = 2x)
    starting_capital: float = 10000.0
    max_concurrent_positions: int = 20
    max_capital_per_pair: float = 1000.0
    enforce_one_position_per_pair: bool = True

    # Execution
    fill_latency_seconds: int = 60  # Delay between signal and fill
    slippage_bps: float = 50  # 0.5% slippage per side

    # Platform fees
    poly_fees: PlatformFees = field(default_factory=lambda: POLYMARKET_FEES)
    kalshi_fees: PlatformFees = field(default_factory=lambda: KALSHI_FEES)


@dataclass
class ArbitrageTrade:
    """A completed (or open) arbitrage trade spanning two platforms."""

    pair_id: str
    polymarket_id: str
    kalshi_ticker: str
    direction: str  # "buy_kalshi" or "buy_poly"

    # Entry
    entry_time: pd.Timestamp
    entry_ts: int
    entry_poly_price: float
    entry_kalshi_price: float
    entry_spread: float

    # Exit (None if still open)
    exit_time: Optional[pd.Timestamp] = None
    exit_ts: Optional[int] = None
    exit_poly_price: Optional[float] = None
    exit_kalshi_price: Optional[float] = None
    exit_spread: Optional[float] = None
    exit_reason: str = ""

    # Position sizing
    position_size: float = 0.0  # Per side

    # P&L
    gross_pnl: float = 0.0
    poly_fees: float = 0.0
    kalshi_fees: float = 0.0
    slippage: float = 0.0
    net_pnl: float = 0.0
    status: str = "open"  # "open" or "closed"

    # Meta
    signal_confidence: float = 0.0
    z_score: float = 0.0


@dataclass
class ArbitrageBacktestResult:
    """Result bundle for a cross-platform arbitrage backtest."""

    strategy_name: str
    trades_df: pd.DataFrame
    daily_returns: pd.Series
    summary: RunSummary
    pairs_analyzed: int = 0
    total_signals: int = 0

    # Platform-level breakdowns
    poly_pnl: float = 0.0
    kalshi_pnl: float = 0.0
    poly_fees_total: float = 0.0
    kalshi_fees_total: float = 0.0

    # Spread statistics
    avg_entry_spread: float = 0.0
    avg_exit_spread: float = 0.0
    avg_holding_periods: float = 0.0


# ---------------------------------------------------------------------------
# Backtest engine
# ---------------------------------------------------------------------------

def _apply_slippage(price: float, side: str, slippage_bps: float) -> float:
    """Apply slippage to a price. Buy = worse (higher), Sell = worse (lower)."""
    slip = slippage_bps / 10000.0
    if side == "buy":
        return min(price * (1 + slip), 0.99)
    else:
        return max(price * (1 - slip), 0.01)


def _compute_leg_pnl(
    entry_price: float,
    exit_price: float,
    position_size: float,
    side: str,
) -> float:
    """
    Compute P&L for one leg of the arbitrage.

    For binary markets:
    - Buy YES at p, market resolves YES -> profit = (1 - p) * size
    - Buy YES at p, exit at p' -> profit = (p' - p) * size
    - Buy NO at p, exit at p' -> profit = (p - p') * size
      (since NO price = 1 - YES price, buying NO benefits from YES falling)

    For pre-resolution exit:
    - Long leg profits from price moving in your direction.
    """
    if side == "buy":
        return (exit_price - entry_price) * position_size
    else:  # sell / short
        return (entry_price - exit_price) * position_size


def run_arbitrage_backtest(
    signals: List[ArbitrageSignal],
    price_store: CrossPlatformPriceStore,
    config: Optional[ArbitrageBacktestConfig] = None,
) -> ArbitrageBacktestResult:
    """
    Run a cross-platform arbitrage backtest.

    Each entry signal opens a two-legged position:
    - If direction == "buy_kalshi": Buy YES on Kalshi, Buy NO on Polymarket
    - If direction == "buy_poly":   Buy YES on Polymarket, Buy NO on Kalshi

    Exit signals close the position (or we mark it open if no exit).

    The arb profit comes from the spread converging. If you buy YES on
    the cheap platform and NO on the expensive one, you profit regardless
    of the outcome, as long as the spread narrows.

    Args:
        signals: List of ArbitrageSignal from ArbitrageStrategy.
        price_store: CrossPlatformPriceStore (for fill price lookups).
        config: Backtest configuration.

    Returns:
        ArbitrageBacktestResult with trades, returns, and summary.
    """
    if config is None:
        config = ArbitrageBacktestConfig()

    trades: List[Dict[str, Any]] = []
    open_positions: Dict[str, Dict[str, Any]] = {}  # pair_id -> position
    capital_in_use = 0.0
    traded_pairs: set = set()

    for signal in signals:
        pair_id = signal.pair_id

        if signal.signal_type == "entry":
            # Check constraints
            if config.enforce_one_position_per_pair and pair_id in traded_pairs:
                continue
            if pair_id in open_positions:
                continue
            if len(open_positions) >= config.max_concurrent_positions:
                continue

            # Determine position size
            size = config.position_size
            remaining_capital = config.starting_capital - capital_in_use
            # Need 2x size (one per leg)
            required_capital = size * 2
            if required_capital > remaining_capital:
                size = remaining_capital / 2
            if size <= 0:
                continue
            if size * 2 > config.max_capital_per_pair:
                size = config.max_capital_per_pair / 2

            # Apply fill latency
            fill_ts = signal.timestamp + config.fill_latency_seconds

            # Get fill prices
            poly_fill = price_store.get_polymarket_price(
                signal.polymarket_id, fill_ts
            )
            kalshi_fill = price_store.get_kalshi_price(
                signal.kalshi_ticker, fill_ts
            )

            # If we can't get fills, use signal prices (common when data is sparse)
            entry_poly = (
                poly_fill["price"] if poly_fill else signal.poly_price
            )
            entry_kalshi = (
                kalshi_fill["price"] if kalshi_fill else signal.kalshi_price
            )
            fill_ts_actual = fill_ts

            # Validate prices
            if entry_poly <= 0 or entry_poly >= 1:
                continue
            if entry_kalshi <= 0 or entry_kalshi >= 1:
                continue

            # Apply slippage
            if signal.direction == "buy_kalshi":
                # Buy YES on Kalshi (price goes up with slippage)
                # Buy NO on Polymarket = sell YES on Polymarket (price goes down)
                entry_kalshi = _apply_slippage(entry_kalshi, "buy", config.slippage_bps)
                entry_poly = _apply_slippage(entry_poly, "sell", config.slippage_bps)
            else:  # buy_poly
                entry_poly = _apply_slippage(entry_poly, "buy", config.slippage_bps)
                entry_kalshi = _apply_slippage(entry_kalshi, "sell", config.slippage_bps)

            open_positions[pair_id] = {
                "pair_id": pair_id,
                "polymarket_id": signal.polymarket_id,
                "kalshi_ticker": signal.kalshi_ticker,
                "direction": signal.direction,
                "entry_ts": fill_ts_actual,
                "entry_poly_price": entry_poly,
                "entry_kalshi_price": entry_kalshi,
                "entry_spread": entry_poly - entry_kalshi,
                "position_size": size,
                "signal_confidence": signal.confidence,
                "z_score": signal.z_score,
            }
            capital_in_use += size * 2
            traded_pairs.add(pair_id)

        elif signal.signal_type == "exit":
            if pair_id not in open_positions:
                continue

            pos = open_positions.pop(pair_id)

            # Get exit prices
            exit_ts = signal.timestamp + config.fill_latency_seconds
            poly_exit = price_store.get_polymarket_price(
                pos["polymarket_id"], exit_ts
            )
            kalshi_exit = price_store.get_kalshi_price(
                pos["kalshi_ticker"], exit_ts
            )

            exit_poly = poly_exit["price"] if poly_exit else signal.poly_price
            exit_kalshi = kalshi_exit["price"] if kalshi_exit else signal.kalshi_price

            # Apply slippage (reverse direction on exit)
            if pos["direction"] == "buy_kalshi":
                exit_kalshi = _apply_slippage(exit_kalshi, "sell", config.slippage_bps)
                exit_poly = _apply_slippage(exit_poly, "buy", config.slippage_bps)
            else:
                exit_poly = _apply_slippage(exit_poly, "sell", config.slippage_bps)
                exit_kalshi = _apply_slippage(exit_kalshi, "buy", config.slippage_bps)

            # Compute P&L per leg
            size = pos["position_size"]

            if pos["direction"] == "buy_kalshi":
                # Kalshi leg: bought YES at entry_kalshi, exit at exit_kalshi
                kalshi_pnl = _compute_leg_pnl(
                    pos["entry_kalshi_price"], exit_kalshi, size, "buy"
                )
                # Poly leg: sold YES at entry_poly (bought NO), exit = buy YES back
                poly_pnl = _compute_leg_pnl(
                    pos["entry_poly_price"], exit_poly, size, "sell"
                )
            else:  # buy_poly
                poly_pnl = _compute_leg_pnl(
                    pos["entry_poly_price"], exit_poly, size, "buy"
                )
                kalshi_pnl = _compute_leg_pnl(
                    pos["entry_kalshi_price"], exit_kalshi, size, "sell"
                )

            gross_pnl = poly_pnl + kalshi_pnl

            # Fees (on profits only)
            poly_fee = max(poly_pnl, 0) * config.poly_fees.profit_fee_rate
            kalshi_fee = max(kalshi_pnl, 0) * config.kalshi_fees.profit_fee_rate
            total_fees = poly_fee + kalshi_fee

            # Slippage is already baked into prices, but track the estimated cost
            slippage_cost = size * 2 * (config.slippage_bps / 10000.0)

            net_pnl = gross_pnl - total_fees

            trade = {
                "pair_id": pos["pair_id"],
                "polymarket_id": pos["polymarket_id"],
                "kalshi_ticker": pos["kalshi_ticker"],
                "direction": pos["direction"],
                "entry_time": pd.to_datetime(pos["entry_ts"], unit="s"),
                "entry_ts": pos["entry_ts"],
                "entry_poly_price": pos["entry_poly_price"],
                "entry_kalshi_price": pos["entry_kalshi_price"],
                "entry_spread": pos["entry_spread"],
                "exit_time": pd.to_datetime(exit_ts, unit="s"),
                "exit_ts": exit_ts,
                "exit_poly_price": exit_poly,
                "exit_kalshi_price": exit_kalshi,
                "exit_spread": exit_poly - exit_kalshi,
                "exit_reason": signal.metadata.get("exit_reason", "signal"),
                "position_size": size,
                "poly_pnl": poly_pnl,
                "kalshi_pnl": kalshi_pnl,
                "gross_pnl": gross_pnl,
                "poly_fees": poly_fee,
                "kalshi_fees": kalshi_fee,
                "total_fees": total_fees,
                "slippage_est": slippage_cost,
                "net_pnl": net_pnl,
                "status": "closed",
                "signal_confidence": pos["signal_confidence"],
                "z_score": pos["z_score"],
                "datetime": pd.to_datetime(pos["entry_ts"], unit="s"),
                "date": pd.to_datetime(pos["entry_ts"], unit="s").date(),
            }
            trades.append(trade)
            capital_in_use -= size * 2

    # Handle remaining open positions
    for pair_id, pos in open_positions.items():
        size = pos["position_size"]
        # Mark as open with last known prices
        trade = {
            "pair_id": pos["pair_id"],
            "polymarket_id": pos["polymarket_id"],
            "kalshi_ticker": pos["kalshi_ticker"],
            "direction": pos["direction"],
            "entry_time": pd.to_datetime(pos["entry_ts"], unit="s"),
            "entry_ts": pos["entry_ts"],
            "entry_poly_price": pos["entry_poly_price"],
            "entry_kalshi_price": pos["entry_kalshi_price"],
            "entry_spread": pos["entry_spread"],
            "exit_time": None,
            "exit_ts": None,
            "exit_poly_price": None,
            "exit_kalshi_price": None,
            "exit_spread": None,
            "exit_reason": "open",
            "position_size": size,
            "poly_pnl": 0.0,
            "kalshi_pnl": 0.0,
            "gross_pnl": 0.0,
            "poly_fees": 0.0,
            "kalshi_fees": 0.0,
            "total_fees": 0.0,
            "slippage_est": 0.0,
            "net_pnl": 0.0,
            "status": "open",
            "signal_confidence": pos["signal_confidence"],
            "z_score": pos["z_score"],
            "datetime": pd.to_datetime(pos["entry_ts"], unit="s"),
            "date": pd.to_datetime(pos["entry_ts"], unit="s").date(),
        }
        trades.append(trade)

    # Build result
    trades_df = pd.DataFrame(trades)
    if not trades_df.empty:
        trades_df = trades_df.sort_values("entry_ts").reset_index(drop=True)
        trades_df["cumulative_pnl"] = trades_df["net_pnl"].cumsum()

    # Daily returns
    daily_returns = pd.Series(dtype=float)
    if not trades_df.empty:
        closed = trades_df[trades_df["status"] == "closed"]
        if not closed.empty:
            daily_returns = compute_daily_returns(
                trades_df=closed,
                starting_capital=config.starting_capital,
            )

    # Build summary
    summary = _build_arb_summary(trades_df, config)

    # Aggregate stats
    closed_df = trades_df[trades_df["status"] == "closed"] if not trades_df.empty else pd.DataFrame()

    result = ArbitrageBacktestResult(
        strategy_name=config.strategy_name,
        trades_df=trades_df,
        daily_returns=daily_returns,
        summary=summary,
        total_signals=len(signals),
        poly_pnl=closed_df["poly_pnl"].sum() if not closed_df.empty else 0.0,
        kalshi_pnl=closed_df["kalshi_pnl"].sum() if not closed_df.empty else 0.0,
        poly_fees_total=closed_df["poly_fees"].sum() if not closed_df.empty else 0.0,
        kalshi_fees_total=closed_df["kalshi_fees"].sum() if not closed_df.empty else 0.0,
        avg_entry_spread=(
            closed_df["entry_spread"].abs().mean() if not closed_df.empty else 0.0
        ),
        avg_exit_spread=(
            closed_df["exit_spread"].abs().mean()
            if not closed_df.empty and "exit_spread" in closed_df.columns
            else 0.0
        ),
    )

    return result


def _build_arb_summary(
    trades_df: pd.DataFrame,
    config: ArbitrageBacktestConfig,
) -> RunSummary:
    """Build RunSummary from arbitrage trades."""
    metadata = RunMetadata(
        strategy_name=config.strategy_name,
        run_type="arbitrage_backtest",
        starting_capital=config.starting_capital,
        position_size=config.position_size,
    )

    metrics = RunMetrics()
    diagnostics = RunDiagnostics()

    if trades_df.empty:
        return RunSummary(metadata=metadata, metrics=metrics, diagnostics=diagnostics)

    closed = trades_df[trades_df["status"] == "closed"]

    metrics.total_trades = len(closed)
    metrics.unique_markets = trades_df["pair_id"].nunique()
    metrics.open_positions = len(trades_df[trades_df["status"] == "open"])

    if not closed.empty:
        winners = closed[closed["net_pnl"] > 0]
        losers = closed[closed["net_pnl"] <= 0]

        metrics.winning_trades = len(winners)
        metrics.losing_trades = len(losers)
        metrics.win_rate = len(winners) / len(closed) if len(closed) > 0 else 0.0

        metrics.total_gross_pnl = closed["gross_pnl"].sum()
        metrics.total_net_pnl = closed["net_pnl"].sum()
        metrics.total_costs = closed["total_fees"].sum()

        metrics.avg_win = winners["net_pnl"].mean() if not winners.empty else 0.0
        metrics.avg_loss = losers["net_pnl"].mean() if not losers.empty else 0.0

        total_wins = winners["net_pnl"].sum() if not winners.empty else 0.0
        total_losses = abs(losers["net_pnl"].sum()) if not losers.empty else 0.0
        metrics.profit_factor = (
            total_wins / total_losses if total_losses > 0 else float("inf")
        )

        metrics.roi_pct = (
            (metrics.total_net_pnl / config.starting_capital) * 100
        )

        # Position sizing stats
        metrics.avg_position_size = closed["position_size"].mean() * 2  # Both legs
        metrics.max_position_size = closed["position_size"].max() * 2

        # Holding time
        if "entry_time" in closed.columns and "exit_time" in closed.columns:
            durations = closed["exit_time"] - closed["entry_time"]
            valid_durations = durations.dropna()
            if not valid_durations.empty:
                metrics.avg_holding_days = (
                    valid_durations.dt.total_seconds().mean() / 86400
                )

        # Sharpe ratio from daily returns
        if not closed.empty and "date" in closed.columns:
            daily_pnl = closed.groupby("date")["net_pnl"].sum()
            if len(daily_pnl) > 1:
                daily_ret = daily_pnl / config.starting_capital
                metrics.sharpe_ratio = (
                    daily_ret.mean() / daily_ret.std() * np.sqrt(365)
                    if daily_ret.std() > 0 else 0.0
                )

        # Max drawdown
        cum_pnl = closed["net_pnl"].cumsum()
        running_max = cum_pnl.cummax()
        drawdown = running_max - cum_pnl
        metrics.max_drawdown = drawdown.max() if not drawdown.empty else 0.0

    return RunSummary(metadata=metadata, metrics=metrics, diagnostics=diagnostics)


# ---------------------------------------------------------------------------
# Display helper
# ---------------------------------------------------------------------------

def print_arbitrage_result(result: ArbitrageBacktestResult) -> None:
    """Print a concise summary of arbitrage backtest results."""
    m = result.summary.metrics
    print(f"\n{'='*65}")
    print(f"STRATEGY: {result.strategy_name}")
    print(f"{'='*65}")
    print(f"Pairs Analyzed:         {result.pairs_analyzed:>12,}")
    print(f"Total Signals:          {result.total_signals:>12,}")
    print(f"Total Trades:           {m.total_trades:>12,}")
    print(f"Win Rate:               {m.win_rate * 100:>11.1f}%")
    print()
    print("--- P&L ---")
    print(f"Gross P&L:              ${m.total_gross_pnl:>12,.2f}")
    print(f"  Polymarket leg:       ${result.poly_pnl:>12,.2f}")
    print(f"  Kalshi leg:           ${result.kalshi_pnl:>12,.2f}")
    print(f"Total Fees:             ${m.total_costs:>12,.2f}")
    print(f"  Polymarket fees:      ${result.poly_fees_total:>12,.2f}")
    print(f"  Kalshi fees:          ${result.kalshi_fees_total:>12,.2f}")
    print(f"Net P&L:                ${m.total_net_pnl:>12,.2f}")
    print(f"ROI:                    {m.roi_pct:>11.2f}%")
    print()
    print("--- Risk ---")
    print(f"Sharpe Ratio:           {m.sharpe_ratio:>12.2f}")
    print(f"Max Drawdown:           ${m.max_drawdown:>12,.2f}")
    print(f"Profit Factor:          {m.profit_factor:>12.2f}")
    print()
    print("--- Spreads ---")
    print(f"Avg Entry Spread:       {result.avg_entry_spread:>11.4f}")
    print(f"Avg Exit Spread:        {result.avg_exit_spread:>11.4f}")
    print(f"Avg Holding (days):     {m.avg_holding_days:>11.1f}")
    print()
    print("--- Positions ---")
    print(f"Avg Position (2-leg):   ${m.avg_position_size:>12,.0f}")
    print(f"Max Position (2-leg):   ${m.max_position_size:>12,.0f}")
    if m.open_positions > 0:
        print(f"Open Positions:         {m.open_positions:>12,}")
    print(f"{'='*65}")
