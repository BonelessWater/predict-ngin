"""
Sentiment divergence strategy.

Looks for divergence between trade flow (sentiment) and price direction.
"""

from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Dict, Any, List, Optional

import pandas as pd


@dataclass
class SentimentSignal:
    """Signal generated by sentiment divergence strategy."""
    timestamp: datetime
    market_id: str
    direction: int
    confidence: float
    signal_type: str
    sentiment: float
    price_change: float


class SentimentDivergenceStrategy:
    """Detects divergence between flow and price change."""

    def __init__(
        self,
        lookback_hours: int = 6,
        divergence_threshold: float = 0.3,
        price_change_threshold: float = 0.02,
        min_trades: int = 10,
        exhaustion_threshold: float = 0.8,
    ):
        self.lookback_hours = lookback_hours
        self.divergence_threshold = divergence_threshold
        self.price_change_threshold = price_change_threshold
        self.min_trades = min_trades
        self.exhaustion_threshold = exhaustion_threshold
        self.name = "sentiment_divergence"

    def calculate_sentiment(
        self,
        trades_df: pd.DataFrame,
        as_of: datetime,
    ) -> Dict[str, Dict[str, float]]:
        """Calculate sentiment metrics per market."""
        if trades_df.empty:
            return {}

        window_start = as_of - timedelta(hours=self.lookback_hours)
        mask = (trades_df["datetime"] >= window_start) & (trades_df["datetime"] <= as_of)
        window = trades_df[mask]
        if window.empty:
            return {}

        metrics: Dict[str, Dict[str, float]] = {}
        for market_id, group in window.groupby("market_id"):
            buys = group[group["taker_direction"].str.lower() == "buy"]["usd_amount"].sum()
            sells = group[group["taker_direction"].str.lower() == "sell"]["usd_amount"].sum()
            total_volume = buys + sells
            trade_count = len(group)
            sentiment = (buys - sells) / total_volume if total_volume > 0 else 0.0
            metrics[market_id] = {
                "buy_volume": buys,
                "sell_volume": sells,
                "total_volume": total_volume,
                "trade_count": trade_count,
                "sentiment": sentiment,
            }

        return metrics

    def _price_change(
        self,
        prices_df: pd.DataFrame,
        market_id: str,
        as_of: datetime,
    ) -> Optional[float]:
        window_start = as_of - timedelta(hours=self.lookback_hours)
        subset = prices_df[prices_df["market_id"] == market_id]
        subset = subset[(subset["datetime"] >= window_start) & (subset["datetime"] <= as_of)]
        subset = subset.sort_values("datetime")
        if len(subset) < 2:
            return None
        first = float(subset.iloc[0]["price"])
        last = float(subset.iloc[-1]["price"])
        if first == 0:
            return None
        return (last - first) / first

    def generate_signals(
        self,
        trades_df: pd.DataFrame,
        prices_df: pd.DataFrame,
        timestamps: Optional[List[datetime]] = None,
    ) -> List[SentimentSignal]:
        if trades_df.empty or prices_df.empty:
            return []

        if "datetime" not in trades_df.columns:
            trades_df = trades_df.copy()
            trades_df["datetime"] = pd.to_datetime(trades_df["timestamp"])

        if timestamps is None:
            start = trades_df["datetime"].min()
            end = trades_df["datetime"].max()
            timestamps = pd.date_range(start, end, freq="1h").tolist()

        signals: List[SentimentSignal] = []

        for ts in timestamps:
            sentiment_metrics = self.calculate_sentiment(trades_df, ts)
            for market_id, metrics in sentiment_metrics.items():
                if metrics["trade_count"] < self.min_trades:
                    continue

                price_change = self._price_change(prices_df, market_id, ts)
                if price_change is None:
                    continue

                sentiment = metrics["sentiment"]
                if sentiment >= self.divergence_threshold and price_change <= -self.price_change_threshold:
                    signals.append(
                        SentimentSignal(
                            timestamp=ts,
                            market_id=market_id,
                            direction=1,
                            confidence=min(abs(sentiment), 1.0),
                            signal_type="bullish_div",
                            sentiment=sentiment,
                            price_change=price_change,
                        )
                    )
                elif sentiment <= -self.divergence_threshold and price_change >= self.price_change_threshold:
                    signals.append(
                        SentimentSignal(
                            timestamp=ts,
                            market_id=market_id,
                            direction=-1,
                            confidence=min(abs(sentiment), 1.0),
                            signal_type="bearish_div",
                            sentiment=sentiment,
                            price_change=price_change,
                        )
                    )

        return signals

    def get_parameters(self) -> Dict[str, Any]:
        """Return strategy parameters."""
        return {
            "lookback_hours": self.lookback_hours,
            "divergence_threshold": self.divergence_threshold,
            "price_change_threshold": self.price_change_threshold,
            "min_trades": self.min_trades,
            "exhaustion_threshold": self.exhaustion_threshold,
        }


__all__ = ["SentimentDivergenceStrategy", "SentimentSignal"]
