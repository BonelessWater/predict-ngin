"""
Breakout strategies for prediction markets.

Detects price consolidation ranges and signals when price breaks out.
Includes a volatility breakout variant.
"""

from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Dict, Any, List, Optional

import numpy as np
import pandas as pd


@dataclass
class BreakoutSignal:
    """Signal generated by breakout strategy."""
    timestamp: datetime
    market_id: str
    direction: int  # 1 = buy, -1 = sell
    confidence: float
    signal_type: str
    range_width: float
    breakout_pct: float
    price: float


class BreakoutStrategy:
    """Range breakout strategy."""

    def __init__(
        self,
        lookback_hours: int = 24,
        breakout_threshold: float = 0.05,
        min_range_width: float = 0.02,
        max_range_width: float = 0.20,
        volume_multiplier: float = 2.0,
    ):
        self.lookback_hours = lookback_hours
        self.breakout_threshold = breakout_threshold
        self.min_range_width = min_range_width
        self.max_range_width = max_range_width
        self.volume_multiplier = volume_multiplier
        self.name = "breakout"

    def detect_range(self, prices: pd.Series) -> Dict[str, float]:
        """Detect consolidation range from a price series."""
        prices = prices.dropna()
        if len(prices) < 10:
            return {}

        high = float(prices.max())
        low = float(prices.min())
        midpoint = (high + low) / 2
        if midpoint == 0:
            return {}

        range_width = (high - low) / midpoint
        return {
            "high": high,
            "low": low,
            "midpoint": midpoint,
            "range_width": range_width,
        }

    def check_breakout(self, current_price: float, range_info: Dict[str, float]) -> Optional[Dict[str, float]]:
        """Check if current price breaks out of the detected range."""
        if not range_info:
            return None

        high = range_info["high"]
        low = range_info["low"]

        if current_price >= high * (1 + self.breakout_threshold):
            breakout_pct = (current_price - high) / max(high, 1e-6)
            return {"direction": 1, "breakout_pct": breakout_pct}
        if current_price <= low * (1 - self.breakout_threshold):
            breakout_pct = (low - current_price) / max(low, 1e-6)
            return {"direction": -1, "breakout_pct": breakout_pct}

        return None

    def generate_signals(self, prices_df: pd.DataFrame) -> List[BreakoutSignal]:
        """Generate breakout signals for each market."""
        if prices_df.empty:
            return []

        signals: List[BreakoutSignal] = []

        for market_id, group in prices_df.groupby("market_id"):
            group = group.sort_values("datetime").dropna(subset=["price"])
            if len(group) < 3:
                continue

            for idx in range(len(group)):
                current_time = group["datetime"].iloc[idx]
                window_start = current_time - timedelta(hours=self.lookback_hours)
                window_df = group[(group["datetime"] >= window_start) & (group["datetime"] < current_time)]
                if len(window_df) < 10:
                    continue

                range_info = self.detect_range(window_df["price"])
                if not range_info:
                    continue

                range_width = range_info["range_width"]
                if range_width < self.min_range_width or range_width > self.max_range_width:
                    continue

                current_price = float(group["price"].iloc[idx])
                breakout = self.check_breakout(current_price, range_info)
                if breakout is None:
                    continue

                direction = breakout["direction"]
                breakout_pct = breakout["breakout_pct"]
                confidence = min(breakout_pct / max(self.breakout_threshold, 1e-6), 1.0)
                signal_type = "upside_breakout" if direction == 1 else "downside_breakout"

                signals.append(
                    BreakoutSignal(
                        timestamp=current_time,
                        market_id=market_id,
                        direction=direction,
                        confidence=confidence,
                        signal_type=signal_type,
                        range_width=range_width,
                        breakout_pct=breakout_pct,
                        price=current_price,
                    )
                )
                break

        return signals

    def get_parameters(self) -> Dict[str, Any]:
        """Return strategy parameters."""
        return {
            "lookback_hours": self.lookback_hours,
            "breakout_threshold": self.breakout_threshold,
            "min_range_width": self.min_range_width,
            "max_range_width": self.max_range_width,
            "volume_multiplier": self.volume_multiplier,
        }


@dataclass
class VolatilityBreakoutSignal:
    """Signal generated by volatility breakout strategy."""
    timestamp: datetime
    market_id: str
    direction: int
    confidence: float
    signal_type: str
    volatility: float


class VolatilityBreakoutStrategy:
    """Detects volatility squeezes followed by expansions."""

    def __init__(
        self,
        lookback_hours: int = 48,
        squeeze_percentile: float = 20,
        expansion_multiplier: float = 1.5,
    ):
        self.lookback_hours = lookback_hours
        self.squeeze_percentile = squeeze_percentile
        self.expansion_multiplier = expansion_multiplier
        self.name = "volatility_breakout"

    def calculate_atr(self, prices: pd.Series, period: int = 14) -> pd.Series:
        """Calculate a simple ATR-like series using close-only prices."""
        true_range = prices.diff().abs()
        atr = true_range.rolling(period, min_periods=period).mean()
        return atr

    def detect_squeeze(self, prices: pd.Series) -> Dict[str, float]:
        """Detect volatility squeeze conditions."""
        if prices.empty:
            return {}

        returns = prices.pct_change().dropna()
        if returns.empty:
            return {}

        vol = returns.rolling(20, min_periods=5).std()
        vol = vol.dropna()
        if vol.empty:
            return {}

        current_vol = float(vol.iloc[-1])
        threshold = float(np.nanpercentile(vol, self.squeeze_percentile))
        return {
            "current_vol": current_vol,
            "threshold": threshold,
            "is_squeeze": current_vol <= threshold,
        }

    def generate_signals(self, prices_df: pd.DataFrame) -> List[VolatilityBreakoutSignal]:
        """Generate volatility breakout signals."""
        if prices_df.empty:
            return []

        signals: List[VolatilityBreakoutSignal] = []

        for market_id, group in prices_df.groupby("market_id"):
            group = group.sort_values("datetime").dropna(subset=["price"])
            if len(group) < 10:
                continue

            end_time = group["datetime"].iloc[-1]
            window_start = end_time - timedelta(hours=self.lookback_hours)
            window_df = group[group["datetime"] >= window_start]
            if len(window_df) < 10:
                continue

            prices = window_df["price"]
            returns = prices.pct_change().dropna()
            if returns.empty:
                continue

            vol = returns.rolling(5, min_periods=5).std()
            vol = vol.dropna()
            if vol.empty:
                continue

            current_vol = float(vol.iloc[-1])
            threshold = float(np.nanpercentile(vol, self.squeeze_percentile))
            recent_vol = vol.iloc[-10:] if len(vol) >= 10 else vol
            min_recent = float(recent_vol.min())

            if min_recent <= threshold and current_vol >= threshold * self.expansion_multiplier:
                direction = 1 if prices.iloc[-1] >= prices.iloc[-2] else -1
                confidence = min(current_vol / max(threshold, 1e-6), 1.0)
                signals.append(
                    VolatilityBreakoutSignal(
                        timestamp=end_time,
                        market_id=market_id,
                        direction=direction,
                        confidence=confidence,
                        signal_type="volatility_expansion",
                        volatility=current_vol,
                    )
                )

        return signals

    def get_parameters(self) -> Dict[str, Any]:
        """Return strategy parameters."""
        return {
            "lookback_hours": self.lookback_hours,
            "squeeze_percentile": self.squeeze_percentile,
            "expansion_multiplier": self.expansion_multiplier,
        }


__all__ = [
    "BreakoutStrategy",
    "BreakoutSignal",
    "VolatilityBreakoutStrategy",
    "VolatilityBreakoutSignal",
]
