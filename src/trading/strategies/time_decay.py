"""
Time decay strategy.

Looks for markets approaching expiry with stale activity or accelerating prices.
"""

from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Dict, Any, List, Optional

import pandas as pd


@dataclass
class TimeDecaySignal:
    """Signal generated by time decay strategy."""
    timestamp: datetime
    market_id: str
    direction: int
    confidence: float
    signal_type: str
    days_to_expiry: float
    price: float


class TimeDecayStrategy:
    """Detects stale markets and accelerating price moves into expiry."""

    def __init__(
        self,
        reversion_threshold: float = 0.15,
        acceleration_threshold: float = 0.85,
        stale_hours: int = 24,
        min_days_to_expiry: int = 1,
        max_days_to_expiry: int = 30,
    ):
        self.reversion_threshold = reversion_threshold
        self.acceleration_threshold = acceleration_threshold
        self.stale_hours = stale_hours
        self.min_days_to_expiry = min_days_to_expiry
        self.max_days_to_expiry = max_days_to_expiry
        self.name = "time_decay"

    def calculate_implied_probability(self, price: float, days_to_expiry: int) -> float:
        """Adjust price for time premium toward resolution."""
        if days_to_expiry <= 0:
            return price
        horizon = min(days_to_expiry, 60)
        premium = min(0.2, horizon / 365 * 0.4)
        return min(1.0, price + premium * (1 - price))

    def expected_price_path(self, price: float, days_to_expiry: int, resolution: float) -> float:
        """Expected daily price move toward a resolution."""
        days = max(days_to_expiry, 1)
        return (resolution - price) / days

    def _latest_price(self, prices_df: pd.DataFrame, market_id: str, as_of: datetime) -> Optional[float]:
        subset = prices_df[prices_df["market_id"] == market_id]
        subset = subset[subset["datetime"] <= as_of].sort_values("datetime")
        if subset.empty:
            return None
        return float(subset.iloc[-1]["price"])

    def _last_trade_time(self, trades_df: pd.DataFrame, market_id: str) -> Optional[datetime]:
        subset = trades_df[trades_df["market_id"] == market_id]
        if subset.empty:
            return None
        return pd.to_datetime(subset["datetime"]).max()

    def generate_signals(
        self,
        markets_df: pd.DataFrame,
        prices_df: pd.DataFrame,
        trades_df: pd.DataFrame,
        as_of: datetime,
    ) -> List[TimeDecaySignal]:
        signals: List[TimeDecaySignal] = []

        if markets_df.empty:
            return signals

        for _, market in markets_df.iterrows():
            market_id = market.get("id")
            if not market_id:
                continue

            end_date = pd.to_datetime(market.get("end_date"), errors="coerce")
            if pd.isna(end_date):
                continue

            days_to_expiry = (end_date - as_of).total_seconds() / 86400
            if days_to_expiry < self.min_days_to_expiry or days_to_expiry > self.max_days_to_expiry:
                continue

            price = self._latest_price(prices_df, market_id, as_of)
            if price is None:
                continue

            last_trade = self._last_trade_time(trades_df, market_id)
            stale_hours = None
            if last_trade is not None:
                stale_hours = (as_of - last_trade).total_seconds() / 3600

            if last_trade is None or stale_hours >= self.stale_hours:
                direction = -1 if price > 0.5 else 1
                signals.append(
                    TimeDecaySignal(
                        timestamp=as_of,
                        market_id=market_id,
                        direction=direction,
                        confidence=0.6,
                        signal_type="stale",
                        days_to_expiry=days_to_expiry,
                        price=price,
                    )
                )

            if price >= self.acceleration_threshold:
                signals.append(
                    TimeDecaySignal(
                        timestamp=as_of,
                        market_id=market_id,
                        direction=1,
                        confidence=min(price, 1.0),
                        signal_type="acceleration",
                        days_to_expiry=days_to_expiry,
                        price=price,
                    )
                )

        return signals

    def get_parameters(self) -> Dict[str, Any]:
        """Return strategy parameters."""
        return {
            "reversion_threshold": self.reversion_threshold,
            "acceleration_threshold": self.acceleration_threshold,
            "stale_hours": self.stale_hours,
            "min_days_to_expiry": self.min_days_to_expiry,
            "max_days_to_expiry": self.max_days_to_expiry,
        }


__all__ = ["TimeDecayStrategy", "TimeDecaySignal"]
